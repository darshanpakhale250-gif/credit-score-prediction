# -*- coding: utf-8 -*-

"""Credit_Score Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Nv6HQEEkbqyu6FsYJh5-aLdDcudGe6Uo
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

df = pd.read_csv('/content/credit_score.csv')

df

df.shape

df.info()

df.isnull().sum().sum()

df = df.drop(columns = ["ID" , "Customer_ID" , "SSN" , "Name" , "Type_of_Loan" , "Credit_History_Age"])

df.head()

df.shape

df.duplicated().sum()

df.describe()

df.isnull().sum()

df.info()



df['Age'].sample(55)

df['Age'] = df['Age'].str.replace("_" , "")

df["Age"] = df["Age"].astype(int)

df["Occupation"].sample(10)

df["Occupation"] = df["Occupation"].replace("_______" , np.nan)

df["Annual_Income"].sample(10)



df["Annual_Income"] = df["Annual_Income"].astype(str).replace("_" , np.nan)

df["Annual_Income"] = df["Annual_Income"].astype(str).str.replace("_" , "", regex=False)
df["Annual_Income"] = df["Annual_Income"].astype(float)

df['Num_of_Loan'].sample(10)

df['Num_of_Loan'] = df['Num_of_Loan'].astype(str).str.replace("_" , "", regex=False)
df['Num_of_Loan'] = df['Num_of_Loan'].astype(int)

df['Num_of_Delayed_Payment'] = df['Num_of_Delayed_Payment'].astype(str).str.replace("_" , "", regex = False)
df['Num_of_Delayed_Payment'] = df['Num_of_Delayed_Payment'].astype(float)

df.info()

df['Changed_Credit_Limit'] = df['Changed_Credit_Limit'].astype(str).str.replace("_" , "", regex = False)
df['Changed_Credit_Limit'] = df['Changed_Credit_Limit'].replace('', np.nan)
df['Changed_Credit_Limit'] = df['Changed_Credit_Limit'].astype(float)

df['Credit_Mix'] = df['Credit_Mix'].replace("_" , np.nan)
df['Credit_Mix'] = df['Credit_Mix'].replace(['Standard' , 'Good' , 'Bad'] , [1,2,0])

df['Credit_Mix'].sample(10)

df.info()

df['Outstanding_Debt'] = df['Outstanding_Debt'].replace("_" , np.nan)
df['Outstanding_Debt'] = df['Outstanding_Debt'].astype(float)

df['Outstanding_Debt'].sample(15)

df['Payment_of_Min_Amount'].sample(10)

df['Payment_of_Min_Amount'] = df['Payment_of_Min_Amount'].replace("NM" , "No")
df['Payment_of_Min_Amount'] = df['Payment_of_Min_Amount'].replace(['Yes' , 'No'] , [1,0])

df.info()

df['Payment_Behaviour'].sample(10)

df['Payment_Behaviour'] = df['Payment_Behaviour'].replace("!@9#%" , np.nan)

df.info()

df['Amount_invested_monthly'].sample(10)



df['Amount_invested_monthly'] = df['Amount_invested_monthly'].astype(str).str.replace("_" , "", regex=False)
df['Amount_invested_monthly'] = df['Amount_invested_monthly'].astype(float)

df['Monthly_Balance'] = df['Monthly_Balance'].replace("_" , np.nan)
df['Monthly_Balance'] = df['Monthly_Balance'].astype(float)

df.info()

df['Credit_Score'] = df['Credit_Score'].replace(['Poor' , 'Standard' , 'Good'] , [0,1,2])

df.isnull().sum()

df = df.fillna(method = 'ffill')
df = df.fillna(method = 'bfill')

df.isnull().sum()

sns.boxplot(df['Age'])
plt.xlabel('Age')
plt.ylabel('count')
plt.show()

col_names = df['Age']
Q1 = col_names.quantile(0.25)
Q3 = col_names.quantile(0.75)
IQR = Q3 - Q1
lower_range = Q1 - 1.5 * IQR
higher_range = Q3 + 1.5 * IQR
data = df[(col_names > lower_range) & (col_names < higher_range)]
sns.boxplot(data['Age'])
plt.xlabel('Age')
plt.ylabel('count')
plt.show()

from sklearn.preprocessing import LabelEncoder
le = LabelEncoder()
for col in ['Month' , 'Occupation' , 'Payment_Behaviour']:
    df[col] = le.fit_transform(df[col])

df.info()

df.info()

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import accuracy_score
from sklearn.linear_model import LogisticRegression
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier
sc = StandardScaler()
lr = LogisticRegression()
X = df.drop(columns = ['Credit_Score'])
Y = df['Credit_Score']
X_train , X_test , Y_train , Y_test = train_test_split(X , Y , test_size = 0.2 , random_state = 42)
X_train = sc.fit_transform(X_train)
X_test = sc.transform(X_test)
lr.fit(X_train , Y_train)
Y_pred = lr.predict(X_test)
accuracy_score(Y_test , Y_pred)

